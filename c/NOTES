Kernel code generation looks sort of like this:

typedef struct {
    $KERNEL_BASE$_t base;
    $KERNEL_FIELDS$ (this includes parameters and prologue vars)
} gezira_$KERNEL_NAME$_t;

nile_Kernel_t *
gezira_$KERNEL_NAME$_clone (nile_t *nl, nile_Kernel_t *k)
{
    gezira_$KERNEL_NAME$_t *k = (gezira_$KERNEL_NAME$_t *) k_;
    gezira_$KERNEL_NAME$_t *clone =
        (gezira_$KERNEL_NAME$_t *) $KERNEL_BASE$_clone (nl, k_);
    $COPY KERNEL PARAMETERS (no need for prologue vars, but it wouldn't hurt$
      $REAL FIELDS ARE COPIED DIRECTLY$
      $KERNELS HAVE TO GO THROUGH THE k->clone() FUNCTION$
    return (nile_Kernel_t *) clone;
}

static void
gezira_$KERNEL_NAME$_process (nile_t *nl, nile_Kernel_t *k_,
                              nile_Buffer_t **in_, nile_Buffer_t **out_)
{
#define IN_QUANTUM $IN_QUANTUM$
#define OUT_QUANTUM $OUT_QUANTUM$
    nile_Buffer_t *in = *in_;
    nile_Buffer_t *out = *out_;
    gezira_$KERNEL_NAME$_t *k = (gezira_$KERNEL_NAME$_t *) k_;
    $KERNEL_FIELDS AS LOCAL VARS$

    if (!k_->initialized) {
        k_->initialized = 1;

        $KERNEL_PROLOGUE$

        $FOR FORWARDING KERNELS, THE FOLLOWING$
            $PEEK_VARS$
            nile_Kernel_t *f =
                $FORWARDING EXPRESSION$

            f->downstream = k_->downstream;
            k_->downstream = f;
    }

    $FOR FORWARDING KERNELS, THE FOLLOWING$
        nile_deliver (nl, k_->downstream, in);
        *in_ = NULL;

    $FOR COMPUTATION KERNELS, THE FOLLOWING$
        while (in->i < in->n) {
            $DECLARE KERNEL_PRIME_VARS$
            NILE_CONSUME_n (in, $KERNEL_INPUT_VARS$);
            $KERNEL_BODY$

            $OUTPUT IS:$
                nile_produce_n (out, $KERNEL_OUTPUT_VARS$);
                out = nile_flush_if_full (nl, k_->downstream, out, OUT_QUANTUM);
            $OR$
                out = nile_produce_n_repeat (...);
            $OR$
                in = nile_rewind (nl, in, IN_QUANTUM);
                nile_produce_n (in, ...);
                in->i -= IN_QUANTUM;

            $KERNEL_PRIME_VARS_UPDATE$
        }

        if (in->eos) {
            $KERNEL_EPILOGUE$
        }
        else {
            $KERNEL_FIELDS WRITE BACK FROM LOCAL VARS$
        }
        *in_ = in;
        *out_ = out;


#undef IN_QUANTUM
#undef OUT_QUANTUM
}

nile_Kernel_t *
gezira_$KERNEL_NAME$ (nile_t *nl,
                     $KERNEL_PARAMETERS$)
{
    gezira_$KERNEL_NAME$_t *k = NILE_KERNEL_NEW (nl, gezira_$KERNEL_NAME$);
    $KERNEL_PARAMETERS_ASSIGNMENT$
    return (nile_Kernel_t *) k;
}
