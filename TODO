- finish pen stroking
    - fix bugs
    - find the right magic number for stroke offset curve
    - reuse joins for caps
    - miter (see formula in cairo)
    - what to do about closed pen paths?
- fix ImageExtendModes!
- c generation
    - nile_loop cannot depend on k->inbox or k->downstream after process
      because the kernel may have deleted itself!
      I think we need to let the loop delete the kernel, in which
      case the look needs to know when in->eos (even though the
      kernel will delete 'in' during process, and the 'in' could
      change during process). Maybe store eos before process, then,
      if inbox is empty, we know that we're done.
      Maybe in this scenario, we don't have to set out->eos in the
      kernel anymore. Just delete 'in'.
    - change groupby so that is doesn't use the downstream field,
      just the v_k field. That will mean that it needs to flush its
      own out buffer? Maybe not a good idea.
    - change kernel_pause to take the pause pointer, so we don't
      forget to set it ourselves
    - kernels have to allocate their out buffer if NULL at function start
    - kernels have to free the in buffer now
    - kernels need to set out->eos when in->eos? NO MORE?
    - kernels have to free themselves now? NO MORE?
    - fill in thread/semaphore code

    - write SDL versions of ReadImage and WriteImage
    - demos
    - make recursion part of the normal scheduling scheme. this will allow ordered
      output, etc. Might need to change order of recursion elements nile code.
      Recursion will now look something like this:

        in->i -= quantum;
        nile_produce_6 (in, 1, 2, 3, 4, 5, 6);
        in->i -= quantum;
        if (in->i < quantum) {
            nile_Buffer_t *in_ = nile_Buffer_split (nl, in);
            nile_Lock_lock (nl->kernellock);
            {
                in->next = k->inbox;
                k->inbox = in;
            }
            nile_Lock_unlock (nl->kernellock);
            in = in_;
        }

    - optimize SortBy for when the input stream is wholly contained
      in the first input buffer. Do an in-place sort and
      just forward the input to the next kernel.
    - rename "initialized" field to something related to first_time
      or prologue or something
    - what about the scheduling heuristic that has the thread execute
      the downstream kernel when all the output fit in one buffer?
    - rename nile_consume and nile_produce to nile_input and nile_output ?
    - what if they give us an input buffer that isn't a multiple of in_quantum?
    - handle limit on number of kernels that can be pipelined.
      we just have to split them up into multiple pipelines, not too hard?
    - document the kernel clone rules (when a kernel is referenced more that
      once in a pipeline expression)
    - kernel constructor calls separate populate function?
      reuse populate function for field write back?
      what about fields that belong to "middle types"?
- document (and add compiler support) for the fact that kernel parameters are
  immutable
- introduce _ vars back into the language
- update PDF doc
- think about restructuring Render this way:

  Mask :: (start : Point) Real >>|

  MaskCanvas (s : Sampler, c : Canvas) : Mask
      ⇒ Interleave (CreateSamplePoints (start) → s, (→)) → c (start)

  MaskSolidColor (color : Color, image : Image) : Mask
      ... primitive code ...

  RenderToMask' (m : Mask) : EdgeContribution >>|
      & [p, w, h]
          ⇒ FillBetweenEdges (p) → m (p + 0.5)

  RenderToMask (m : Mask) : EdgeContribution >>|
      ⇒ GroupBy (@p.y, SortBy (@p.x) → RenderToMask' (m))

- parser
- javascript generation
- fix font problem on windows (add missing chars to DejaVu Sans Mono and/or Inconsolata)
- make zlib.nl and png.nl real
- what about things like 2b + 0.5c
    - math mode? (single letter variables, etc.?)
      perhaps only in the body of ∀ blocks?
- cubic >> quadratic bezier kernel
- image filters (blur, etc.)
