- finish pen stroking
    - fix bugs
    - find the right magic number for stroke offset curve
    - reuse joins for caps
    - miter (see formula in cairo)
    - what to do about closed pen paths?
- fix ImageExtendModes!
- c generation
    - fill in thread/semaphore code

    - kernels now have to allocate their out buffer if NULL at function start
    - kernels now have to free the in buffer now

    - debug
    - write SDL versions of ReadImage and WriteImage
    - demos

    - make recursion part of the normal scheduling scheme. this will allow ordered
      output, etc. Might need to change order of recursion elements nile code.
      Recursion will now look something like this:

        in->i -= quantum;
        nile_produce_6 (in, 1, 2, 3, 4, 5, 6);
        in->i -= quantum;
        if (in->i < quantum) {
            nile_Buffer_t *in_ = nile_Buffer_split (nl, in);
            nile_Lock_lock (nl->kernellock);
            {
                in->next = k->inbox;
                k->inbox = in;
            }
            nile_Lock_unlock (nl->kernellock);
            in = in_;
        }

    - comments by Alex:
        - prearrange freelist
        - have freelist operate on buffers
        - alignment of freelist nodes (make them e.g., 512 bytes large and
          align them?)
    - one spin lock per kernel?
    - optimize SortBy for when the input stream is wholly contained
      in the first input buffer. Do an in-place sort and
      just forward the input to the next kernel.
    - rename "initialized" field to something related to first_time
      or prologue or something
    - what about the scheduling heuristic that has the thread execute
      the downstream kernel when all the output fit in one buffer?
    - rename nile_consume and nile_produce to nile_input and nile_output ?
    - what if they give us an input buffer that isn't a multiple of in_quantum?
    - handle limit on number of kernels that can be pipelined.
      we just have to split them up into multiple pipelines, not too hard?
    - document the kernel clone rules (when a kernel is referenced more that
      once in a pipeline expression)
    - kernel constructor calls separate populate function?
      reuse populate function for field write back?
      what about fields that belong to "middle types"?
- document (and add compiler support) for the fact that kernel parameters are
  immutable
- introduce _ vars back into the language
- update PDF doc
- think about restructuring Render this way:

  Mask :: (start : Point) Real >>|

  MaskCanvas (s : Sampler, c : Canvas) : Mask
      ⇒ Interleave (CreateSamplePoints (start) → s, (→)) → c (start)

  MaskSolidColor (color : Color, image : Image) : Mask
      ... primitive code ...

  RenderToMask' (m : Mask) : EdgeContribution >>|
      & [p, w, h]
          ⇒ FillBetweenEdges (p) → m (p + 0.5)

  RenderToMask (m : Mask) : EdgeContribution >>|
      ⇒ GroupBy (@p.y, SortBy (@p.x) → RenderToMask' (m))

- parser
- javascript generation
- fix font problem on windows (add missing chars to DejaVu Sans Mono and/or Inconsolata)
- make zlib.nl and png.nl real
- what about things like 2b + 0.5c
    - math mode? (single letter variables, etc.?)
      perhaps only in the body of ∀ blocks?
- cubic >> quadratic bezier kernel
- image filters (blur, etc.)
